# language: zh-TW
功能: 日誌記錄、錯誤處理與測試策略

  背景:
    假設 Bot 需要在生產環境穩定運行
    而且需要完善的日誌以便除錯與監控
    而且需要統一的錯誤處理機制避免程序崩潰
    而且需要自動化測試確保功能正確性

  情境: 結構化日誌輸出
    當系統執行任何操作時
    那麼必須使用結構化日誌格式(JSON Lines)
    而且每條日誌至少包含
      | 欄位 | 說明 |
      | timestamp | ISO 8601 格式時間戳 |
      | level | 日誌等級(DEBUG/INFO/WARN/ERROR/FATAL) |
      | module | 產生日誌的模組名稱 |
      | message | 人類可讀的訊息 |
      | context | 相關上下文資料(物件) |
    而且日誌必須輸出到 stdout
    而且錯誤日誌(ERROR/FATAL)必須輸出到 stderr

  情境: 日誌等級可透過環境變數控制
    當系統啟動時
    那麼必須讀取 LOG_LEVEL 環境變數
    而且允許的值為 DEBUG/INFO/WARN/ERROR/FATAL
    而且預設為 INFO
    而且開發環境建議使用 DEBUG
    而且生產環境建議使用 INFO 或 WARN
    而且只輸出等於或高於設定等級的日誌

  情境: 敏感資訊不得記錄到日誌
    當記錄日誌時
    那麼系統必須過濾敏感資訊
    而且至少包含
      | 敏感資訊類型 | 處理方式 |
      | API tokens | 完全移除或遮罩為 ****** |
      | 使用者私訊內容 | 僅記錄 metadata 不記錄內容 |
      | 密碼或金鑰 | 完全移除 |
    而且日誌處理層必須自動偵測並遮罩常見 token 格式
    而且在 DEBUG 模式下也不得記錄敏感資訊

  情境: 統一的錯誤處理機制
    當系統任何模組發生錯誤
    那麼必須使用統一的錯誤類別階層
    而且至少包含
      | 錯誤類別 | 用途 |
      | ConfigError | 配置檔載入或驗證錯誤 |
      | PlatformError | 平台 API 呼叫錯誤 |
      | AgentError | Agent 執行錯誤 |
      | MemoryError | 記憶檔案讀寫錯誤 |
      | SkillError | Skill 執行錯誤 |
    而且每個錯誤必須包含明確的錯誤碼與可操作的錯誤訊息
    而且錯誤必須被記錄後妥善處理

  情境: 錯誤不得導致整個 Bot 崩潰
    當單一 Agent session 執行發生錯誤
    那麼系統必須捕捉該錯誤
    而且記錄完整的錯誤堆疊到日誌
    而且向平台發送簡化的錯誤訊息(不洩漏內部細節)
    而且繼續處理其他互動事件
    而且不得因單一錯誤導致整個程序終止

  情境: 平台連線錯誤需自動重連
    當與平台(Discord/Misskey)的連線中斷
    那麼系統必須記錄連線錯誤
    而且必須實作指數退避重連機制
    而且重連間隔至少包含
      | 重連次數 | 等待時間 |
      | 1-3 | 1-5 秒 |
      | 4-6 | 10-30 秒 |
      | 7+ | 60 秒 |
    而且重連成功後必須記錄 INFO 級別日誌
    而且連續失敗超過設定次數後記錄 FATAL 並終止程序

  情境: 單元測試覆蓋核心邏輯
    當開發核心功能時
    那麼必須為每個模組撰寫單元測試
    而且測試檔案必須與被測試檔案對應
    而且測試檔案命名為 {module_name}.test.ts
    而且測試必須可獨立執行不依賴外部服務
    而且使用 mock 或 stub 隔離外部依賴

  情境: 整合測試驗證端到端流程
    當需要測試完整互動流程時
    那麼可以撰寫整合測試
    而且整合測試檔案命名為 {feature_name}.integration.test.ts
    而且整合測試可以使用測試用配置與測試用 working directory
    而且整合測試必須在獨立的測試環境執行
    而且不得影響生產環境資料

  情境: 使用 Deno 內建測試框架
    當撰寫測試時
    那麼必須使用 Deno.test() 作為測試框架
    而且使用 @std/assert 模組進行斷言
    而且測試必須有清楚的描述說明測試意圖
    而且測試必須能通過 deno test 指令執行
    而且測試輸出必須清楚指出失敗原因

  情境: CI/CD 必須執行完整測試與檢查
    當提交程式碼到版本控制
    那麼 CI pipeline 必須執行
      | 檢查項目 | 指令 |
      | 程式碼格式化檢查 | deno fmt --check |
      | 程式碼品質檢查 | deno lint |
      | 型別檢查 | deno check src/main.ts |
      | 單元測試 | deno test |
      | 整合測試 | deno test --filter integration |
    而且所有檢查必須通過才能合併程式碼
    而且測試失敗必須阻止部署

  情境: 效能監控與指標收集
    當 Bot 運行時
    那麼系統應記錄關鍵效能指標
    而且至少包含
      | 指標 | 說明 |
      | agent_session_duration | 每次 Agent 執行時長 |
      | platform_api_latency | 平台 API 呼叫延遲 |
      | memory_file_size | 記憶檔案大小 |
      | active_sessions | 並行處理的 session 數 |
    而且指標可透過日誌輸出或專用監控端點暴露
    而且在容器環境可選擇性整合 Prometheus 或類似工具

  情境: 健康檢查端點
    當系統在容器或 Kubernetes 環境運行
    那麼應提供 HTTP 健康檢查端點
    而且端點路徑為 GET /health 或 GET /healthz
    而且端點回應
      | 狀態碼 | 條件 |
      | 200 | Bot 正常運行且平台連線正常 |
      | 503 | Bot 啟動中或平台連線中斷 |
    而且回應 body 可包含簡單的狀態資訊(JSON 格式)
    而且健康檢查不得執行耗時操作
